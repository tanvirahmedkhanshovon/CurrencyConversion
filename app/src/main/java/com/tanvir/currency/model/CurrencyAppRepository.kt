package com.tanvir.currency.modelimport android.app.Applicationimport androidx.lifecycle.MutableLiveDataimport com.tanvir.currency.BuildConfigimport com.tanvir.currency.db.CurrencyDatabaseimport com.tanvir.currency.db.CurrencyRateDaoimport com.tanvir.currency.db.SharedPrefimport com.tanvir.currency.db.SupportedCurrenciesDaoimport com.tanvir.currency.service.CurrencyDataServiceimport com.tanvir.currency.service.RetrofitInstanceimport com.tanvir.currency.util.NetworkUtilimport io.reactivex.rxjava3.android.schedulers.AndroidSchedulersimport io.reactivex.rxjava3.core.Completableimport io.reactivex.rxjava3.core.Observableimport io.reactivex.rxjava3.disposables.CompositeDisposableimport io.reactivex.rxjava3.observers.DisposableCompletableObserverimport io.reactivex.rxjava3.observers.DisposableObserverimport io.reactivex.rxjava3.schedulers.Schedulersimport java.util.concurrent.TimeUnitimport javax.inject.Singleton@Singletonclass CurrencyAppRepository    (application: Application, sharedPref: SharedPref) {    private var app: Application = application    val preference: SharedPref = sharedPref    private val service: CurrencyDataService = RetrofitInstance.service    private val compositeDisposable = CompositeDisposable()    private val currencyDatabase = CurrencyDatabase.getInstance(app)    private val dao: SupportedCurrenciesDao = currencyDatabase!!.countriesDao    private val currencyRateDao: CurrencyRateDao = currencyDatabase!!.currencyRateDao    private var returnData: MutableLiveData<List<CurrencyRateToDisplay>?> = MutableLiveData()    private val accessKey = BuildConfig.ACCESS_TOKEN    private var supportedCurrencyResponseMutableLiveData: MutableLiveData<List<SupportedCurrency>?> =        MutableLiveData()    private var currencyRateResponseMutableLiveData: MutableLiveData<List<CurrencyRate>?> =        MutableLiveData()    private var currencyToDisplayMutableLiveData: MutableLiveData<List<CurrencyRateToDisplay>?> =        MutableLiveData()    fun getSupportedCurrencies(): MutableLiveData<List<SupportedCurrency>?> {        val localData = getSupportedCurrenciesFromCache()        if (!localData.value.isNullOrEmpty()) {            return localData        }        return if (isConnceted()) {            getSupportedCurrenciesFromApi()        } else {            localData        }    }    private fun getSupportedCurrenciesFromApi(): MutableLiveData<List<SupportedCurrency>?> {        val requestToPayResponseObservable: Observable<SupportedCurrenciesResponse> =            service.getSupportedCountries(accessKey)        var supportedCurrencyResponse  = listOf<SupportedCurrency>()        compositeDisposable.add(            requestToPayResponseObservable                .subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread())                .subscribeWith(object : DisposableObserver<SupportedCurrenciesResponse?>() {                    override fun onNext(t: SupportedCurrenciesResponse?) {                     if(t?.success == true) {                         supportedCurrencyResponse =                             getSupportedCurrenciesList(t?.supportedCurrenciesMap)                         compositeDisposable.add(Completable.fromAction {                             dao.insert(                                 supportedCurrencyResponse                             )                         }                             .subscribeOn(Schedulers.io())                             .observeOn(AndroidSchedulers.mainThread())                             .subscribeWith(object : DisposableCompletableObserver() {                                 override fun onComplete() {}                                 override fun onError(e: Throwable) {}                             })                         )                     }                    }                    override fun onError(e: Throwable) {                    }                    override fun onComplete() {                        supportedCurrencyResponseMutableLiveData.postValue(supportedCurrencyResponse)                    }                })        )        return supportedCurrencyResponseMutableLiveData    }    fun getCurrencyRate(): MutableLiveData<List<CurrencyRateToDisplay>?> {        val localData = getCurrencyRateToDisplayFromCache()        val fetchFromAPINeeded = fetchFromAPINeeded()        if (!fetchFromAPINeeded ) {            return localData        }        if (isConnceted()) {            getCurrencyRateFromApi()        }        return returnData    }    private fun getCurrencyRateFromApi(): MutableLiveData<List<CurrencyRate>?> {        val requestToPayResponseObservable: Observable<CurrencyRateResponse> =            service.getCurrencyRate(accessKey)        var currencyRateResponse = listOf<CurrencyRate>()        compositeDisposable.add(            requestToPayResponseObservable                .subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread())                .subscribeWith(object : DisposableObserver<CurrencyRateResponse?>() {                    override fun onNext(t: CurrencyRateResponse?) {                        if(t?.success == true) {                            currencyRateResponse =                                getCurrencyRateList(t?.rates)                            compositeDisposable.add(Completable.fromAction {                                currencyRateDao.insert(currencyRateResponse)                            }                                .subscribeOn(Schedulers.io())                                .observeOn(AndroidSchedulers.mainThread())                                .subscribeWith(object : DisposableCompletableObserver() {                                    override fun onComplete() {                                        preference.saveLastFetchedTime(System.currentTimeMillis())                                        returnData = getCurrencyRateToDisplayFromCache()                                    }                                    override fun onError(e: Throwable) {}                                })                            )                        }                    }                    override fun onError(e: Throwable) {//                    }                    override fun onComplete() {                        currencyRateResponseMutableLiveData.postValue(currencyRateResponse)                    }                })        )        return currencyRateResponseMutableLiveData    }    private fun getSupportedCurrenciesFromCache(): MutableLiveData<List<SupportedCurrency>?> {        supportedCurrencyResponseMutableLiveData = MutableLiveData()        compositeDisposable.add(dao.findAll()            .subscribeOn(Schedulers.computation())            .observeOn(AndroidSchedulers.mainThread())            .subscribe { currencyList ->                supportedCurrencyResponseMutableLiveData.postValue(currencyList)            }        )        return supportedCurrencyResponseMutableLiveData    }    private fun getCurrencyRateToDisplayFromCache(): MutableLiveData<List<CurrencyRateToDisplay>?> {        currencyToDisplayMutableLiveData = MutableLiveData()        compositeDisposable.add(currencyRateDao.getAllCurrencyRateWithCountryName()            .subscribeOn(Schedulers.computation())            .observeOn(AndroidSchedulers.mainThread())            .subscribe { currencyRateList ->                currencyToDisplayMutableLiveData.postValue(currencyRateList)            }        )        return currencyToDisplayMutableLiveData    }    private fun getSupportedCurrenciesList(map: Map<String, String>?): List<SupportedCurrency> {        val list = ArrayList<SupportedCurrency>()        if (!map.isNullOrEmpty()) {            val keys = map.keys            for (key in keys) {                val rate = SupportedCurrency(key, map[key])                list.add(rate)            }        }        return list    }    private fun getCurrencyRateList(map: Map<String, Double>?): List<CurrencyRate> {        val list = ArrayList<CurrencyRate>()        if (!map.isNullOrEmpty()) {            val keys = map.keys            for (key in keys) {                var k: String                if (!key.endsWith("USD", true)) {                    k = key.replace("USD", "", true)                } else {                    k = "USD"                }                val rate = CurrencyRate(k, map[key])                list.add(rate)            }        }        return list    }    fun clear() {        compositeDisposable.clear()    }    fun isConnceted(): Boolean {        return NetworkUtil.isConnected(app)    }    private fun fetchFromAPINeeded(): Boolean {        val currentTimestamp = System.currentTimeMillis()        val fetchTimeStamp = getLastFetchedTime()        val difference = TimeUnit.MINUTES.toMillis(30)        return currentTimestamp - fetchTimeStamp > difference    }    private fun getLastFetchedTime(): Long {        return preference.getFetchedTime()    }}